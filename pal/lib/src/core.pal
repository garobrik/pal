id = <T>(t: T){t}

--------------------

Eq: <T:>(T1: T, T2: T)[Type] = <T>(T1, T2) { (R:, f: ((T1)[T2], (T2)[T1])[R])[R] }

refl: <T:, v: T> [ Eq<_>(v, v) ] = <T, v, R>(f) { f(id<_>, id<_>) }

subst: <T:, T1: T, T2: T>(P: Eq<_>(T1, T2), a: T1)[T2] = <T, T1, T2>(P) { P<_>((to, _){to}) }

substr: <T:, T1: T, T2: T>(P: Eq<_>(T1, T2), a: T2)[T1] = <T, T1, T2>(P) { P<_>((_, from){from}) }

--------------------

Nat: Type = <Result:>(baseCase: Result, inductiveStep: (Result)[Result])[Result]

zero: Nat = <Result>(baseCase, _){baseCase}

next: (Nat)[Nat] = (previous) {
  <Result>(baseCase, inductiveStep: (Result)[Result]) {
    inductiveStep(previous<_>(baseCase, inductiveStep))
  }
}

--------------------

applyNTimes: <P: <Nat>[Type]>(num: Nat, <n: Nat>(P<n>) [ P<next(n)> ], P<zero>) [ P<num> ]

--------------------

List = <Element> {
  <Result:>(initial: Result, combine: (Element, Result)[Result])[Result]
}

empty: <Element:> [ List<Element> ] = <Element, Result>(initial, _){initial}

prepend: <Element:>(Element, List<Element>) [ List<Element> ] = 
  <Element>(element: Element, list: List<Element>) {
    <Result>(initial, combine: (Element, Result)[Result]) {
      list<_>(combine(element, initial), combine)
    }
  }

fold: <Result:, Element:>(Result, (Element, Result)[Result], List<Element>)[Result] = 
  <Result, Element>(initial, combine: (Element, Result)[Result], list: List<Element>) {
    list<_>(initial, combine)
  }

prop_fold_empty: <Result:, Element:, initial: Result, combine: (Element, Result)[Result]> [
  Eq<_>(fold<_, _>(initial, combine, empty<_>), initial)
] = <_, _, _, _> { refl<_, _> }

prop_fold_prepend: 
  <Result:, Element:, initial: Result, combine: (Element, Result)[Result], element: Element, list: List<E>> [
    Eq<_>(
      fold<_, _>(initial, combine, prepend<_>(element, list)),
      fold<_, _>(combine(element, initial), combine, list)
    )
  ] = <_, _, _, _, _, _> { refl<_, _> }

--------------------

dfold: 
  <E: Type, P: <List<E>>[Type]>(P<empty<E>>, (l: List<E>, e: E, P<l>) [ P<prepend<E>(e, l)> ], l: List<E>) [
    P<l>
  ]

--------------------

append: <E: Type>(E, List<E>) [ List<E> ] = 
  <E: Type>(elem: E) { fold<List<E>, E>(prepend<E>(elem, empty<E>), prepend<E>) }

--------------------

reverse: <E: Type>(List<E>) [ List<E> ] = <E: Type> {
  fold<List<E>, E>(empty<E>, (e: E, r: List<E>) { prepend<E>(e, r) })
}

foldr: <R: Type, E: Type>(R, (E, R)[R], List<E>)[R] = 
  <R: Type, E: Type>(init: R, f: (E, R)[R], l: List<E>) {
    fold<R, E>(init, f, reverse<E>(l))
  }

prop_foldr_pre: <R: Type, E: Type, e: E, l: List<E>, init: R, f: (E, R)[R]> [
  Eq<R, f(e, foldr<R, E>(init, f, l)), foldr<R, E>(init, f, prepend<E>(e, l))>
]

prop_foldr_app: <R: Type, E: Type, e: E, l: List<E>, init: R, f: (E, R)[R]> [
  Eq<R, foldr<R, E>(f(e, init), f, l), foldr<R, E>(init, f, append<E>(e, l))>
]

--------------------

List2Fn: <Type, List<Type>>[Type] = <R: Type, L: List<Type>> {
  foldr<Type, Type>(R, (E: Type, Acc: Type) { (E)[Acc] }, L)
}

prop_List2Fn_emp: <R: Type> [ Eq<Type, List2Fn<R, empty<Type>>, R> ] = <R: Type> { refl<Type, R> }

prop_List2Fn_pre: <R: Type, L: List<Type>, E: Type> [
  Eq<Type, List2Fn<R, prepend<Type>(E, L)>, (E) [ List2Fn<R, L> ]>
]

prop_List2Fn_app: <R: Type, L: List<Type>, E: Type> [
  Eq<Type, List2Fn<(E)[R], L>, List2Fn<R, append<Type>(E, L)>>
]

--------------------

HList: <List<Type>>[Type] = <L: List<Type>> { <R: Type>(List2Fn<R, L>)[R] }

HListInd = <L: List<Type>> {
  (W: List<Type>, w: HList<W>) [
    List2Fn<(R: Type, List2Fn<List2Fn<R, L>, W>)[R], L>
  ]
}

mkHList: <L: List<Type>> [ List2Fn<HList<L>, L> ] = <L: List<Type>> {
  dfold<Type, HListInd>(
    (W: List<Type>, w: HList<W>){w},
    (Rest: List<Type>, E: Type, acc: HListInd<Rest>, W: List<Type>, w: HList<W>) {
      substr<
        Type,
        List2Fn<
          (R: Type, List2Fn<List2Fn<R, W>, append<Type>(E, Rest)>)[R],
          prepend<Type>(E, Rest)
        >,
        (E) [
          List2Fn<
            (R: Type, List2Fn<List2Fn<R, W>, append<Type>(E, Rest)>)[R],
            Rest
          >
        ]
      >(
        prop_List2Fn_pre<
          (R: Type, List2Fn<List2Fn<R, W>, append<Type>(E, Rest)>)[R],
          Rest,
          E
        >,
        (e: E) {
          acc(
            append<Type>(E, W),
            <R: Type>(f: List2Fn<R, append<Type>(E, W)>) {
              w<(E)[R]>(
                substr<
                  Type,
                  List2Fn<(E)[R], W>,
                  List2Fn<R, append<Type>(E, W)>
                >(
                  prop_List2Fn_app<R, W, E>,
                  f
                ),
                e
              )
            }
          )
        }
      )
    },
    L,
    empty<Type>,
    id
  )
}
